# Hacking_Job_Descriptions
Along my journey to find a job I am both passionate about and qualified for, I've noticed unfamiliar terms and tools in some interesting job descriptions. In some cases I'll Google them and find out that I do have those skills afterall (I just wasn't using the same terminology) or wonder if maybe I should take some time to learn how to use a new software to make my resume more appealing. I thought it would be a fun and useful project to parse through jobs I've saved and compile a list of the most commonly desired skills.  

## Tools Used
This project is written in Python, using the [Selenium automation tool](https://selenium-python.readthedocs.io/) interfaced with [ChromeDriver](https://chromedriver.chromium.org/) to pull job descriptions from preset LinkedIn job postings and using [NLTK](https://www.nltk.org/) to parse the text for valuable information. [Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/bs4/doc/) was also used to help pull the LinkedIn links from an exported HTML file of the user's bookmarks.  

## How it Works
The user starts by bookmarking the LinkedIn posts they want to examine and using their browser to export their bookmarks bar to an HTML file, which needs to be saved as <code>bookmarks.html</code> in the same directory as the scripts. Running [job_descriptions.py](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/job_descriptions.py) will prompt the user for their LinkedIn username and password, which is necessary so that the job postings can be expanded. It is important that the LinkedIn account does NOT have two-factor authentication turned on for the automation to work properly. [ChromeDriver](https://chromedriver.chromium.org/) will open and [Selenium](https://selenium-python.readthedocs.io/) will pull the job descriptions from every LinkedIn bookmark. All the descriptions will be output to [Job Descriptions.txt](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/Job%20Descriptions.txt).  

After running [job_descriptions.py](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/job_descriptions.py) with your own links (or if you just want to use my gathered data), [parse_job_descriptions.py](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/parse_job_descriptions.py) needs to be run to analyze the data. It tokenizes all the words from [Job Descriptions.txt](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/Job%20Descriptions.txt) then removes punctuation, stop words (common words that are unhelpful out of the context of a sentence), and a manually compiled list of unhelpful words. The manually compiled list can be found starting on [line 18](https://github.com/monk200/Hacking_Job_Descriptions/blob/ab7caca03e4f9b5a9e5da953bf4c56dcb5495701/parse_job_descriptions.py#L18) and was created by looking at the most common words and intuitively deciding that they are not going to help find desireable skills. Usually these words are broadly related to engineering, clearly from "equal opportunity" blurbs, or generic job posting words. After cleaning the data, the script searches for the most common individual words, bigrams, and trigrams. It will also create [individual_words.txt](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/individual_words.txt), which can quickly be uploaded to a word cloud generator for a graphical view of the common terms.  

## Results
The ultimate goal here is that the ouputted words, bigrams, and trigrams give insights into what skills are most commonly desired in the job postings I am interested in. Unfortunately, the outputted lists are not particularly helpful. The individual words list looks as expected but the top 30 words don't contain any skills or terms I don't already have and wasn't expecting to see. Looking at less popular words might reveal more by avoiding obvious terms. As far as the bigrams and trigrams, they all have just one occurance because each job post is written uniquely enough that phrases aren't overlapping the way I had anticipated. To try to fix this I used the found list of bigrams and counted their number of appearances ignoring order, hoping this would show more meaningful data. Again this failed to add any meaning to my data.  

The word cloud created from my initial smaller dataset can be seen below, followed by a word cloud from a much larger dataset. This portion of the result was at least helpful in brainstorming words to use in my resume and visualize the general tone of the jobs I've been applying to.  

![wordCloud.PNG](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/wordCloud.PNG)
![wordCloud2.PNG](https://github.com/monk200/Hacking_Job_Descriptions/blob/main/wordCloud2.PNG)  

## Future Work
At the time of writing this, I'm a little stumped on what changes to make to this approach to still reach my desired goal of finding new skills to add to my repertoire. The job posts were written much more unquiely than I anticipated so the skills weren't highlighted with my language processing approach. I intend to look through the entire list of individual words since the 100th most used word is still something that has shown up about 20 times and a skill is probably still useful if it shows up just 5 times. I think it might also help to only save the portion of the job description following keywords such as "qualifications" since this would cut out the fluff from the beggining of the post. The downside here would probably be that it would cut out a lot of the soft skills recruiters are looking for.  

If anyone reading this has thoughts or suggestions, I'm open to hearing them!
